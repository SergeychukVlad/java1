S8 Заключение

1. Переопределение методов equals и hashCode.

                от методов equals и hashCode требуется согласованность, поэтому переопределять их надо в паре
                хеш-коды нужны для быстрого поиска, добавления, удаления в некоторых структурах данных(в частности во всех содержащих в названии слово "Hash")
                написание equals и hashCode требует соблюдения определённых правил (контрактов)
                генерация equals и hashCode средой - простое, быстрое и удачное решение в большинстве случаев


2. Абстрактные классы. Запрет наследования. Интерфейсы.

                абстрактный класс определяет шаблон для классов наследников через определение абстрактных методов
                класс - наследник абстрактного класса должен:
                            либо реализовать абстрактные методы родителя
                            либо сам быть абстрактным
                запрет наследования осуществляется модификатором final
                Generic (обобщения) это передача типов в класс как параметров
                интерфейсы - второе измерение полиморфизма (наследование - первое)
                интерфейсы можно наследовать
                реализация интерфейса Comparable позволяет сортировать массивы (и другие структуры) объектов


3. Модификатор static, вложенные и внутренние классы.

                статические переменные (в том числе константы) и методы видны всем элементам программы (с поправкой на модификаторы доступа переменной и её класса)
                из статических методов нет доступа к переменным объекта, поскольку нет привязки этих методов к объектам
                статические переменные и методы следует вызывать, предваряя их именем класса
                статический конструктор предназначен для инициализации значений статических переменных
                статический импорт позволяет использовать "короткие" имена статических переменных и методов
                внутренние удобны при описании объектов, привязанных к внешнему классу и имеющих смысл только внутри него
                внутренние классы видят все свойства объекта внешнего класса
                конструктор внутреннего класса может быть вызван только из объекта внешнего класса
                вложенные классы позволяют описать несколько классов внутри одного файла, что удобно при описании простых классов, связанных логически с внешним
                вложенные классы - это обычные классы с двумя особенностями:
                обращение к статическим свойствам и методам внешнего класса возможно по короткому имени (без указания имени класса)
                для обращения к вложенному классу за рамками внешнего класса требуется указать длинное имя (с указанием имени внешнего класса)

